{%- macro smart_title_case(text) -%}
{%- for i in range(0, text | length) -%}
    {%- if i == 0 or text[i-1] in ['.', '_'] -%}
        {{ text[i] | upper }}
    {%- elif not text[i] in ['.', '_'] -%}
        {{ text[i] }}
    {%- endif -%}
{%- endfor -%}
{%- endmacro -%}
{%- macro attribute_struct_field(attr) %}{{ smart_title_case(attr.name) }} {% if attr.requirement_level != "required" %}*{% endif %}{{attr.type | map_text("attribute_type_value") }}{%- endmacro -%}
package o11y

import (
	"context"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

// DO NOT MODIFY: This code is autogenerated.
// See templates/registry/go/metric.go.j2.

{% for metric in ctx %}
{% set metric_name = smart_title_case(metric.metric_name) %}
{% set metric_attribute_struct_name = metric_name ~ "Attributes" %}
{% if metric.attributes | length > 0 %}
{# Create known atrecommendedtributes for this metric #}
type {{ metric_attribute_struct_name }} struct {
{% for attr in metric.attributes %}
  {{ attr.brief | comment | trim }}
  {{ attribute_struct_field(attr) }}
{% endfor %}
}

func (attrs {{ metric_attribute_struct_name }}) asMeasurementOptions() metric.MeasurementOption {
  {# TODO - we can optimise this. #}
  return metric.WithAttributes(
{% for attr in metric.attributes %}
{% if attr.requirement_level != "required" %}
    if attrs.{{ smart_title_case(attr.name) }} != nil {
      attribute.{{ attr.type | map_text("attribute_type_method")}}("{{ attr.name }}", *attrs.{{ smart_title_case(attr.name) }}),
    }
{% else %}
    attribute.{{ attr.type | map_text("attribute_type_method")}}("{{ attr.name }}", attrs.{{ smart_title_case(attr.name) }}),
{% endif %}
{% endfor %}
  ) 
}

{% endif %}



{# Create typesafe wrapper for counter #}
{{ ["An instrument for recording `" ~ metric.metric_name ~ "`"] | comment | trim }}
type {{ smart_title_case(metric.metric_name) }} interface {
    {# TODO - a different method for Counter vs. Histogram vs. Gauge #}
{% if metric.attributes | length > 0 %}
    // Adds to the current count.
    Add(context.Context, {{ metric_attribute_struct_name }}, float64)
{% else %}
    // Adds to the current count.
    Add(context.Context, float64)
{% endif %}
}

{{ ["Construct a new instrument for measuring `" ~ metric.metric_name ~ "`"] | comment }}
func New{{ smart_title_case(metric.metric_name) }}(m metric.Meter) ({{ smart_title_case(metric.metric_name) }}, error) {
    i, err := m.{{metric.instrument | map_text("metric_type_interface")}}(
        "{{metric.metric_name}}",
        metric.WithDescription("{{metric.brief}}"),
        metric.WithUnit("{{metric.unit}}"),
    )
    if err != nil {
        return nil, err
    }
    return wrapper{{ smart_title_case(metric.metric_name) }}{&i}, nil
}

type wrapper{{ smart_title_case(metric.metric_name) }} struct {
    instrument *metric.{{metric.instrument | map_text("metric_type_interface")}}
}
{# TODO - a different wrapper method #}
{% if metric.attributes | length > 0 %}
func (m wrapper{{ smart_title_case(metric.metric_name) }}) Add(ctx context.Context, attrs {{ metric_attribute_struct_name }}, inc float64) {
    (*m.instrument).Add(ctx, inc, attrs.asMeasurementOptions())
}
{% else %}
func (m wrapper{{ smart_title_case(metric.metric_name) }}) Add(ctx context.Context, inc float64) {
    (*m.instrument).Add(ctx, inc)
}
{% endif %}

{% endfor %}