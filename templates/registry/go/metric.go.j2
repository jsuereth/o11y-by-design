{%- macro smart_title_case(text) -%}
{%- for i in range(0, text | length) -%}
    {%- if i == 0 or text[i-1] in ['.', '_'] -%}
        {{ text[i] | upper }}
    {%- elif not text[i] in ['.', '_'] -%}
        {{ text[i] }}
    {%- endif -%}
{%- endfor -%}
{%- endmacro -%}
package metrics

import (
	"context"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

// DO NOT MODIFY: This code is autogenerated.  See {tbd}/metric.go.j2.

{% for metric in ctx %}

type {{ smart_title_case(metric.metric_name) }} interface {
    {# TODO - a different method for Counter vs. Histogram vs. Gauge #}
    Add(context.Context, float64)
}

func New{{ smart_title_case(metric.metric_name) }}(m metric.Meter) ({{ smart_title_case(metric.metric_name) }}, error) {
    i, err := m.{{metric.instrument | map_text("metric_type_interface")}}(
        "{{metric.metric_name}}",
        metric.WithDescription("{{metric.brief}}"),
        metric.WithUnit("{{metric.unit}}"),
    )
    if err != nil {
        return nil, err
    }
    return {{ smart_title_case(metric.metric_name) }}Wrapper{&i}, nil
}

type {{ smart_title_case(metric.metric_name) }}Wrapper struct {
    instrument *metric.{{metric.instrument | map_text("metric_type_interface")}}
}
{# TODO - a different wrapper method #}
func (m {{ smart_title_case(metric.metric_name) }}Wrapper) Add(ctx context.Context, inc float64) {
    (*m.instrument).Add(ctx, inc)
}

{% endfor %}